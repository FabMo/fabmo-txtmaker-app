<!doctype html>
<html>
	<head>
		<title>TxtMaker</title>
		<link rel="stylesheet" type="text/css" href="css/style.css">
      <link rel='stylesheet' href='css/nprogress.css'/>
	</head>

<body onload="reload();">
	
      <script type="text/javascript" src="js/opentype.min.js"></script>
      <script type="text/javascript" src="js/processing.min.js"></script>
      <script type="text/javascript" src="js/dat.gui.min.js"></script>
      <script type="text/javascript" src="js/snap.svg-min.js"></script>
      <script type="text/javascript" src="js/nprogress.js"></script>
      <script type="text/javascript" src="js/dashboard.js"></script>
      <script type="text/javascript" src="js/jquery-1.11.2.min.js"></script>

<control>
<input type="text" name="txt" id="textbox" value="Txt">
<button onclick="reload();">DRAW</button>
<input type="file" id="file">LOAD FONT (TTF)</input>

</control>

<script type="text/javascript">
var font;
var click = 0;

function onReadFile(evt) {
    NProgress.start();
    var f = evt.target.files[0]; 

    if (f) {

      var r = new FileReader();
      r.onload = function(e) { 
	     var contents = e.target.result;
        
        font = opentype.parse(e.target.result);
        alert( "LOADING TEXT");
        onFontLoaded(font);

      }

      r.readAsText(f);
    } else { 
      alert("Failed to load file");
    }
  r.readAsArrayBuffer(f);
click=1;
font=font;
}

document.getElementById('file').addEventListener('change', onReadFile, false);

function reload(){

alert("LOADING TEXT");
if(click == 0){
loadfont();
loadtxt();
}
else{
onFontLoaded(font);
}

}

</script>

<script>

//dat gui
var obj = {
txtheight : 50,
gcode : false,
feedrate : 800,
plungerate : 300,
cd : -2,
texty : 0,
xgrid : 10,
fontheight : 50,
td : 3.2,
border : 6.5,
showborder : false,
tabs : false,

}

var gc = [" "];
var gcode = [" "];

var w = 200;
var h = 150;
var sl = obj.fontheight/10;

var sf = window.innerHeight/h;

w = w*sf;
h = h*sf-30;

var obj2 = {make:function() {
obj.gcode=true;

}}
var gui1 = new dat.GUI();

var f1 = gui1.addFolder('setup');
f1.add(obj, 'feedrate', 1, 2000).step(10).name('feedrate');
f1.add(obj, 'plungerate', 1, 1000).step(10).name('plungerate');
f1.add(obj, 'td', 0.8, 12.6).step(0.8).name('tool diameter');
f1.add(obj, 'cd', -25, 0).step(1).name('cut depth');
f1.add(obj, 'border', 2, 50).step(1).name('frame offset');
f1.add(obj, 'showborder').name('show frame');
f1.add(obj, 'tabs').name('tabs');
//f1.add(obj, 'texty', 0, 200).listen().name('Y position');
f1.add(obj, 'xgrid', 5, 100).step(5).name('grid spacing');
f1.add(obj, 'txtheight', 1, 250).step(1).listen().name('text size');
var height = f1.add(obj, 'fontheight', 10, 250).step(1).name('font size');

gui1.add(obj2, 'make').name('MAKE TEXT');

f1.open();

height.onFinishChange(function(value) {

reload();

});

var x = [""];
var y = [""];
var xc = [""];
var yc = [""];
var g = [" "];
var xm;
var ym;
var xi;
var yi;


var fontFileName;

function loadfont() {
fontFileName = 'fonts/Roboto-Black.ttf';
}

function loadtxt() {
NProgress.start();
opentype.load(fontFileName, function(err, font) 
{
if (err) 
{
alert('Font could not be loaded: ' + err);
} 
else  
{
onFontLoaded(font);
}
});

}


function onFontLoaded(font) {

//sl = obj.txtheight/10;

//console.log(obj.txtheight);

NProgress.set(0.5)
var txt = document.getElementById("textbox").value;
var path = font.getPath(txt, 0, h, sf*obj.fontheight);
var svg = path.toSVG(2);
var len = Snap.path.getTotalLength(svg).toFixed(0);



for (i2 = 0; i2 < len; i2=i2+sl) {


var one = Snap.path.getPointAtLength(svg, i2);
//var circle = paper.circle(one.x, one.y, 1);
x.splice(i2,1,one.x.toFixed(2));
y.splice(i2,1,one.y.toFixed(2));

}


NProgress.done();
yi = Math.min.apply(Math, y);
xi = Math.min.apply(Math, x);
xm = Math.max.apply(Math, x);
ym = Math.max.apply(Math, y);
xc = x;
yc = y;
//console.log(x);
//console.log(y);
x = []; 
y = [];
svg = [];
yc[yc.length-1]="end";
xc[xc.length-1]="0";
        

}

</script>

<script type="application/processing" data-processing-target="mycanvas">
////////////////////////////////////////////////////////////////////////


//todo
//tabs and multipass
float x0;
float y0;

int mx=10*sf;
int my=10*sf;
int ymax;
int ymin;
int xmax;
int xmin;

int xo=0;
int yo=0;

int i0=0;
int i1=0;

ArrayList vx;
ArrayList vy;

String[] pathx;
String[] pathy;

String[] xp = {};
String[] yp = {};

float pn;//pass no
int pd;//pass depth
int p = 1;

int texth;

int [] yscale;
int [] yscale;
int [] outline;

int ox1;
int oy1;
int ox2;
int oy2;

void setup()
{

size(w,h);
background(0,130,0);
strokeJoin(ROUND);

vx = new ArrayList();
vy = new ArrayList();
 
}

void draw()
{  
background(0,130,0);
rectMode(CORNERS);
noFill();

sl = int(obj.fontheight/10);

ox1 = round((mx+xi)-(obj.border*sf));
oy1 = round(((h-my)+obj.border*sf)+(ymax*sf)-(obj.td/2)*sf);
ox2 = round((mx)+(xm)+(obj.border*sf));
oy2 = round((h-my)-(obj.txtheight+obj.border)*sf);

pn = ceil(abs(obj.cd)/obj.td);
pd = nf((obj.cd/pn),1,2);

ymin = min(yc);
ymax = ((ym-h)/sf);
texth=int(h-ymin);
obj.txtheight=(texth/sf)+1.6;


stroke(0,135,235);
strokeWeight(3);
rect((10*sf)-1,(h-10*sf)+1,150*sf,h-120*sf);

if(obj.showborder==true){
stroke(180);
strokeWeight(obj.td*sf);
rect(ox1,oy1,ox2,oy2);//border
}

stroke(170);
strokeWeight(1);
line(0,h,w,h);
line(0,h,0,0);

fill(255,255,0);
ellipse(10*sf, h-10*sf, 2*sf, 2*sf);
noFill();

for(i=1; i<=w/obj.xgrid*sf; i++){
line(0,h-i*obj.xgrid*sf,w,h-i*obj.xgrid*sf);
}

for(i=1; i<=h/obj.xgrid*sf; i++){
line(i*obj.xgrid*sf,h,i*obj.xgrid*sf,0);
}

translate(mx, 0-my-((obj.td*sf)/2));

stroke(255,0,0,220);
strokeWeight(1);

line(0,h+sf,20,h+sf);
line(0,h-(texth+sf),20,h-(texth+sf));
line(0,h+sf,0,h-(texth+sf));

stroke(255,200);
strokeWeight(obj.td*sf);


beginShape();

for (int i = 0; i < xc.length-1; i = i+1) {

   if((abs(xc[i]-xc[i-1]) > sl*2) || (abs(yc[i]-yc[i-1]) > sl*2)){

      endShape(CLOSE);
      beginShape();

   }

   else{
      vertex(xc[i], yc[i]);
   }

}

endShape(CLOSE);



if(obj.gcode==true){
makegcode();
makeg();

obj.gcode=false;
}

}

void go(){

for (int i3 = 0; i3 < pathx.length; i3=i3+1) {

   if(i3==0){
      //header
      //gc = splice(gc," ",0);
      gc = splice(gc,"g0z4",0);
      gc = splice(gc,"g0x" + pathx[i3] + "y" + pathy[i3],0);
      gc = splice(gc,"g1z" + pd + "f" + obj.plungerate,0);
      gc = splice(gc,"f" + obj.feedrate,0);
      //header
   }

   else{
      gc = splice(gc,"g1x" + pathx[i3] + "y" + pathy[i3],0);
   }

}

if(pn>1){
//multipass
for (p; p <= pn; p++){

   for (int i3 = 0; i3 < pathx.length; i3=i3+1) {

      if(i3==0){
      //header
      //gc = splice(gc," ",0);

      gc = splice(gc,"g1x" + pathx[i3] + "y" + pathy[i3],0);
      gc = splice(gc,"g1z" + pd*p + "f" + obj.plungerate,0);
      gc = splice(gc,"f" + obj.feedrate,0);
      //header
      }


      else{
      gc = splice(gc,"g1x" + pathx[i3] + "y" + pathy[i3],0);
      }

   }
}

}
p=1

}


void makeg(){

gc = splice(gc,"g21",0);
gc = splice(gc,"g0z4",0);
gc = splice(gc,"m4",0);
gc = splice(gc,"g4p0.5",0);

   for (int i = 0; i < vx.size() ; i++) {

      pathx=vx.get(i);
      pathy=vy.get(i);
      go();

   }

if (obj.showborder==true){

//border
gc = splice(gc,"g0z4",0);
gc = splice(gc,"g0x"+ ((xo+(xi/sf))-obj.border) + "y" + ((yo+((h/sf)-(ym/sf)))-obj.border),0);
gc = splice(gc,"g1z" + pd*p + "f" + obj.plungerate,0);
gc = splice(gc,"f" + obj.feedrate,0);
gc = splice(gc,"g1x"+ ((xo+(xm/sf))+obj.border)  + "y" + ((yo+((h/sf)-(ym/sf)))-obj.border),0);
gc = splice(gc,"g1x"+ ((xo+(xm/sf))+obj.border)  + "y" + ((yo+((h/sf)-(ymin/sf)))+obj.border),0);
gc = splice(gc,"g1x"+ ((xo+(xi/sf))-obj.border)  + "y" + ((yo+((h/sf)-(ymin/sf)))+obj.border),0);
gc = splice(gc,"g1x"+ ((xo+(xi/sf))-obj.border)  + "y" + ((yo+((h/sf)-(ym/sf)))-obj.border),0);

p = 2;
//

if(pn>1){

for (p; p <= pn; p++){

gc = splice(gc,"g1z" + pd*p + "f" + obj.plungerate,0);
gc = splice(gc,"f" + obj.feedrate,0);
gc = splice(gc,"g1x"+ ((xo+(xi/sf))-obj.border) + "y" + ((yo+((h/sf)-(ym/sf)))-obj.border),0);
gc = splice(gc,"g1x"+ ((xo+(xm/sf))+obj.border)  + "y" + ((yo+((h/sf)-(ym/sf)))-obj.border),0);
gc = splice(gc,"g1x"+ ((xo+(xm/sf))+obj.border)  + "y" + ((yo+((h/sf)-(ymin/sf)))+obj.border),0);
gc = splice(gc,"g1x"+ ((xo+(xi/sf))-obj.border)  + "y" + ((yo+((h/sf)-(ymin/sf)))+obj.border),0);
gc = splice(gc,"g1x"+ ((xo+(xi/sf))-obj.border)  + "y" + ((yo+((h/sf)-(ym/sf)))-obj.border),0);
p = p++;

}

}

}

gc = splice(gc,"g0z4",0);
gc = splice(gc,"m5",0);
gc = splice(gc,"g0x0y0",0);
gc = splice(gc,"m30",0);


String[] sa = reverse(gc);
g = join(sa, "\n");
//console.log(sa);
fabmoDashboard.submitJob(g, {filename : 'TxtMaker.g', name : 'TxtMaker', description : 'Generated by TxtMaker'});

gc=[];
g=[];
s=[];

vx.clear();
vy.clear();

}



void makegcode(){

//header();

for (int i = 0; i < xc.length-1; i = i+1) {

if(i==0){


x0 = nf((xc[0]/sf)+xo,1,2);
y0 = nf(((h+obj.texty*sf-yc[0])/sf)+yo,1,2);
i0=i;

}

//move to next path
else if((abs(xc[i]-xc[i-1]) > sl*2) || (abs(yc[i]-yc[i-1]) > sl*2)){

int c = i0;

while (i0 < i1) {

if (i0==c){

xp = splice(xp,x0,i1);
yp = splice(yp,y0,i1);

}

else{
xp = splice(xp,nf((xc[i0]/sf)+xo, 1, 2),i1);
yp = splice(yp,nf(((h+obj.texty*sf-yc[i0])/sf)+yo, 1, 2),i1);
}

i0++;

}
xp = splice(xp,x0,i1+1);
yp = splice(yp,y0,i1+1);

vx.add(xp);
vy.add(yp);

xp=[];
yp=[];


x0 = nf((xc[i]/sf)+xo,1,2);
y0 = nf(((h+obj.texty*sf-yc[i])/sf)+yo,1,2);
i0=i+1;

}

else{
gcode = splice(gcode,"g1x" + nf((xc[i]/sf)+xo, 1, 2) + "y" + nf(((h+obj.texty*sf-yc[i])/sf)+yo, 1, 2) ,1);
i1=i;
}

}

footer();

gc=[];
gcode=[];
g=[];
s=[];

}

void mouseClicked() {

mx=mouseX;
my=h-mouseY;

xo=int((mx/sf)-(10));
yo=int((my/sf)-(10));



console.log(pn);
//println(sl);



}



void footer()
{


int c = i0;

while (i0 < i1) {

if (i0==c){

xp = splice(xp,x0,i1);
yp = splice(yp,y0,i1);

}

else{
xp = splice(xp,nf((xc[i0]/sf)+xo, 1, 2),i1);
yp = splice(yp,nf(((h+obj.texty*sf-yc[i0])/sf)+yo, 1, 2),i1);
}

i0++;

}

xp = splice(xp,x0,i1+1);
yp = splice(yp,y0,i1+1);

vx.add(xp);
vy.add(yp);

xp=[];
yp=[];

}

</script>

<canvas id="mycanvas"> </canvas>

</body>
</html>
